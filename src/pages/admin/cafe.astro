---
import Layout from '../../layouts/Layout.astro';
import { checkAuth } from '../../lib/auth';
import { supabase } from '../../lib/supabase';
import { CoffeeLogSchema, CoffeeBeanSchema } from '../../lib/schemas/cafe';
import CoffeeLogForm from '../../components/cafe/CoffeeLogForm';
import type { CoffeeBeanRow, CoffeeLogWithBean } from '../../lib/schemas/cafe';
import type { BREW_METHODS } from '../../lib/schemas/cafe';
import {
  calculateStats,
  getBrewMethodDistribution,
  getQualityOverTime,
  getMostUsedBeans,
  formatBrewRatio,
} from '../../lib/cafe-stats';
import BrewMethodChart from '../../components/cafe/BrewMethodChart';
import QualityChart from '../../components/cafe/QualityChart';
import { getLocaleFromUrl, useTranslations } from '@/lib/i18n';

const locale = getLocaleFromUrl(Astro.url);
const { t, formatDate } = useTranslations(locale);

export const prerender = false;

// Check authentication
const isAuthed = checkAuth(Astro.cookies);
if (!isAuthed) {
  return Astro.redirect('/admin');
}

let message = '';
let messageType: 'success' | 'error' | null = null;

// Handle form submission
if (Astro.request.method === 'POST') {
  if (!supabase) {
    message = 'Error: Supabase is not configured';
    messageType = 'error';
  } else {
    try {
      const formData = await Astro.request.formData();
      const action = formData.get('action');

      if (action === 'add_bean') {
        // Parse and validate bean data
        const rawBeanData = {
          bean_name: formData.get('bean_name') as string,
          roaster: formData.get('roaster') || null,
          roast_date: formData.get('roast_date') || null,
          notes: formData.get('notes') || null,
          is_active: true,
        };

        const validatedBeanData = CoffeeBeanSchema.parse(rawBeanData);

        // Insert into database
        const { data: newBean, error } = await supabase
          .from('coffee_beans')
          .insert(validatedBeanData)
          .select()
          .single();

        if (error) throw error;

        // Check if this is an AJAX request (React component)
        const acceptHeader = Astro.request.headers.get('accept');
        if (acceptHeader?.includes('application/json')) {
          // Return JSON for React component
          return new Response(JSON.stringify({ bean: newBean }), {
            status: 200,
            headers: { 'Content-Type': 'application/json' },
          });
        } else {
          // Fallback: traditional form submission with page refresh
          message = 'Bean added successfully!';
          messageType = 'success';
        }
      } else if (action === 'log_coffee') {
        // Parse and validate
        const rawData = {
          brew_method: formData.get('brew_method'),
          bean_id: formData.get('bean_id') || null,
          dose_grams: Number(formData.get('dose_grams')),
          yield_grams: formData.get('yield_grams') ? Number(formData.get('yield_grams')) : null,
          grind_setting: Number(formData.get('grind_setting')),
          quality_rating: Number(formData.get('quality_rating')),
          brew_time: formData.get('brew_time') as string,
          notes: formData.get('notes') || null,
        };

        const validatedData = CoffeeLogSchema.parse(rawData);

        // Insert into database
        const { error } = await supabase.from('coffee_logs').insert({
          brew_method: validatedData.brew_method,
          bean_id: validatedData.bean_id,
          dose_grams: validatedData.dose_grams,
          yield_grams: validatedData.yield_grams,
          grind_setting: validatedData.grind_setting,
          quality_rating: validatedData.quality_rating,
          brew_time: validatedData.brew_time,
          notes: validatedData.notes,
        });

        if (error) throw error;

        message = 'Coffee logged successfully!';
        messageType = 'success';
      }
    } catch (error) {
      console.error('Error logging coffee:', error);
      if (error instanceof Error) {
        message = `Error: ${error.message}`;
      } else {
        message = 'Error: Unknown error occurred';
      }
      messageType = 'error';
    }
  }
}

// Fetch active beans for dropdown
let activeBeans: CoffeeBeanRow[] = [];
if (supabase) {
  try {
    const { data } = await supabase
      .from('coffee_beans')
      .select('*')
      .eq('is_active', true)
      .order('created_at', { ascending: false });

    activeBeans = data || [];
  } catch (error) {
    console.warn('Could not fetch beans:', error);
  }
}

// Fetch smart defaults from last coffee log
type BrewMethod = (typeof BREW_METHODS)[number];

let smartDefaults: {
  brew_method: BrewMethod | null;
  grind_setting: number | null;
  dose_grams: number | null;
  yield_grams: number | null;
} = {
  brew_method: null,
  grind_setting: null,
  dose_grams: null,
  yield_grams: null,
};

if (supabase) {
  try {
    const { data } = await supabase
      .from('coffee_logs')
      .select('brew_method, grind_setting, dose_grams, yield_grams')
      .order('brew_time', { ascending: false })
      .limit(1)
      .single();

    if (data) {
      smartDefaults = data;
    }
  } catch (error) {
    // No previous logs or error - use hardcoded defaults
    console.warn('Could not fetch smart defaults:', error);
  }
}

// Fetch all coffee logs with bean details for display
let logs: CoffeeLogWithBean[] = [];
if (supabase) {
  try {
    const { data, error: fetchError } = await supabase
      .from('coffee_logs')
      .select('*, bean:coffee_beans(*)')
      .order('brew_time', { ascending: false })
      .limit(100);

    if (fetchError) throw fetchError;
    logs = (data || []) as CoffeeLogWithBean[];
  } catch (e) {
    console.error('Error fetching coffee logs:', e);
  }
}

// Calculate statistics
const stats = logs.length > 0 ? calculateStats(logs) : null;
const brewMethodData = logs.length > 0 ? getBrewMethodDistribution(logs) : [];
const qualityData = logs.length > 0 ? getQualityOverTime(logs) : [];
const topBeans = logs.length > 0 ? getMostUsedBeans(logs) : [];
const recentLogs = logs.slice(0, 30); // Show last 30
---

<Layout title={t('cafe.title')} isAdmin={true}>
  <nav class="mb">
    <a href="/admin"> ‚Üê Panel de Admin </a>
  </nav>

  <header class="mb">
    <h1>{t('cafe.heading')}</h1>
    <p>{t('cafe.subtitle')}</p>
  </header>

  {
    !supabase ? (
      <section class="notice-box" data-variant="warning">
        <h2>{t('cafe.errors.heading')}</h2>
        <p>{t('cafe.errors.notConfigured')}</p>
        <a href="/admin" role="button">
          {t('cafe.errors.setupButton')}
        </a>
      </section>
    ) : (
      <>
        <section>
          {message && messageType && (
            <div class="notice-box" data-variant={messageType === 'success' ? 'success' : 'error'}>
              {message}
            </div>
          )}

          <CoffeeLogForm client:load activeBeans={activeBeans} smartDefaults={smartDefaults} />
        </section>

        {logs.length > 0 && (
          <>
            <hr style="margin: 3rem 0;" />

            {/* Stats Cards */}
            <div class="grid-3 mb">
              <article class="stat-card">
                <small>{t('cafe.stats.totalLogs')}</small>
                <p class="stat-value">{stats?.totalLogs}</p>
              </article>
              <article class="stat-card">
                <small>{t('cafe.stats.thisWeek')}</small>
                <p class="stat-value">{stats?.logsThisWeek}</p>
              </article>
              <article class="stat-card">
                <small>{t('cafe.stats.avgRating')}</small>
                <p class="stat-value">{stats?.avgRating} / 5</p>
              </article>
            </div>

            {/* Visualizations */}
            <div class="grid-2 mb">
              {/* Brew Method Distribution */}
              <article>
                <h2>{t('cafe.sections.brewMethods')}</h2>
                <BrewMethodChart client:load data={brewMethodData} />
              </article>

              {/* Quality Over Time */}
              <article>
                <h2>{t('cafe.sections.qualityOverTime')}</h2>
                <QualityChart client:load data={qualityData} />
              </article>
            </div>

            {/* Most Used Beans */}
            {topBeans.length > 0 && (
              <article class="mb">
                <h2>{t('cafe.sections.topBeans')}</h2>
                {topBeans.map((item) => (
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
                    <div>
                      <strong>{item.bean.bean_name}</strong>
                      {item.bean.roaster && (
                        <small style="display: block;">{item.bean.roaster}</small>
                      )}
                    </div>
                    <small>
                      {item.count} {t('cafe.misc.brews')}
                    </small>
                  </div>
                ))}
              </article>
            )}

            {/* Recent Logs Table */}
            <article>
              <h2>{t('cafe.sections.recentBrews')}</h2>
              <div style="overflow-x: auto;">
                <table>
                  <thead>
                    <tr>
                      <th>{t('cafe.table.date')}</th>
                      <th>{t('cafe.table.bean')}</th>
                      <th>{t('cafe.table.method')}</th>
                      <th>{t('cafe.table.ratio')}</th>
                      <th>{t('cafe.table.grind')}</th>
                      <th>{t('cafe.table.rating')}</th>
                      <th>{t('cafe.table.notes')}</th>
                    </tr>
                  </thead>
                  <tbody>
                    {recentLogs.map((log) => (
                      <tr>
                        <td>
                          {formatDate(new Date(log.brew_time), {
                            month: 'short',
                            day: 'numeric',
                          })}
                        </td>
                        <td>{log.bean?.bean_name || <small>{t('cafe.misc.unknown')}</small>}</td>
                        <td>{log.brew_method}</td>
                        <td style="font-family: monospace;">
                          {formatBrewRatio(log.dose_grams, log.yield_grams)}
                        </td>
                        <td>{log.grind_setting}</td>
                        <td>{log.quality_rating} / 5</td>
                        <td style="max-width: 300px; overflow: hidden; text-overflow: ellipsis;">
                          <small>{log.notes || '-'}</small>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </article>
          </>
        )}
      </>
    )
  }
</Layout>

<script>
  import { initBeans } from '@/stores/beansStore';

  // Initialize beans store with server data
  const beansData = document.getElementById('beans-data')?.textContent;
  if (beansData) {
    try {
      const beans = JSON.parse(beansData);
      initBeans(beans);
    } catch (e) {
      console.error('Failed to parse beans data:', e);
    }
  }
</script>

<script id="beans-data" type="application/json" set:html={JSON.stringify(activeBeans)} />

<style>
  /* Responsive table */
  @media (max-width: 768px) {
    table {
      font-size: 0.875rem;
    }
    th,
    td {
      padding: 0.5rem 0.25rem;
    }
  }
</style>
